---
title: "Differential Gene Expression in MSCs"
author: "Ramil Hakim"
date: "`r format(Sys.time(), '%d %B %Y')`"
output: 
  html_document:
    theme: flatly
    toc: true
    number_sections: true
    toc_float:
      collapsed: false
      smooth_scroll: false
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```
# Executive Summary





# Project Description

**Hypothesis:** *The transcriptome of bone marrow derived mesenchymal stem cells (MSCs) transplanted into a spinal cord injury environment is altered as compared to MSCs transplanted into uninjured spinal cord.*

**Experimental setup & sequencing:** mCherry+MSCs were transplanted into injured (75 kdyn contusion injury, 24h post SCI) or uninjured spinal cord using a glas capillary pipette. C57BL/6J female mice were utilized. At 7 days post transplantation the mCherry+MSCs were FACSed. Injured and uninjured (when applicable) were used for setting positive mCherry gate. Total RNA, digested of DNase, was isolated and sequenced (125 cycles paired-end) in two lane using the HiSeq2500 system and v4 sequencing chemistry (Illumina Inc.) performed by the SNP&SEQ Technology Platform (Stockholm, Sweden).   

**Data analysis:** A read count matrix was obtained from the sequencing core facility. Data was analyed using the edgeR and limma packages (both available through bioconductor.org) using R version 3.4.1. Two additional key packages used were ggplot2 and data.table.    

***

# Data Overview

```{r echo=F, warning=F, message=F, error=F}
# #1. Installing packages
# source("https://bioconductor.org/biocLite.R")
# biocLite("limma")

# source("https://bioconductor.org/biocLite.R")
# biocLite("edgeR")

# source("https://bioconductor.org/biocLite.R")
# biocLite("Mus.musculus")

#install.packages("data.table")
#install.packages("ggplot2")
#install.packages("cowplot")
#install.packages("RColorBrewer")
#install.packages("gplots")
#install.packages("pvclust")
#install.packages("VennDiagram")
# install.packages("rafalib")
#install.packages("grid")
#install.packages("colorspace")
#install.packages("ellipse")
#install.packages("ggrepel")
#install.packages("rafalib")
#install.packages("boot")
#install.packages("pvclust")
#install.packages("RCurl")
#install.packages("XML")
#install.packages("xml2")
# install.packages("caret")
# install.packages("Rtsne")

#2. Attaching packages
library(limma)
library(edgeR)
library(Mus.musculus)

library(data.table)
library(ggplot2)
library(cowplot)
library(gridExtra)
library(grid)

library(colorspace)
library(RColorBrewer)
library(gplots)
library(VennDiagram)
library(ellipse)
library(ggrepel)
library(rafalib)

library(boot)
library(pvclust)

library(knitr)
library(pander)

library(RCurl)
library(XML)
library(xml2)

library(caret)
library(Rtsne)

rm(list=ls())

#Importing function for sharing legend 
source("/home/ramhak/Dropbox/PHD/PAPER I/R_v2/Function_directory/get_legend.R")
```

```{r echo=F, warning=F, message=F, error=F}
############## IMPORTING DATA & ANNOTATING GENES & ORGANISING META DATA #############
```

```{r echo=F, warning=F, message=F, error=F}
#1. Importing read count matrix
DT_read_count <- fread("merged_gene_counts.txt", header=T)
names(DT_read_count) <- c(names(DT_read_count)[1], do.call(rbind, lapply(names(DT_read_count)[2:length(names(DT_read_count))], function(col_name){substr(col_name, 7, 9)})))

#2. Retrieving gene annotations (SYMBOL) based on ENSEMBL_ID
gene_annotations <- data.table(select(Mus.musculus, keys=DT_read_count[,as.character(ENSEMBL_ID)], columns="SYMBOL", keytype = "ENSEMBL"))

#3. Removing duplicates in retrieved annotations
gene_annotations <- gene_annotations[!duplicated(ENSEMBL)]

#4. Adding gene annotations to read_count_matrix 
DT_read_count <- merge(DT_read_count, gene_annotations, by.x="ENSEMBL_ID", by.y="ENSEMBL")
DT_read_count <- setcolorder(DT_read_count, c(1,24,2:23))

#5. Importing meta_data
DT_meta_data <- fread("meta_data.csv")
DT_meta_data <- DT_meta_data[Status=="Included", !c("RH.index", "Status")]
names(DT_meta_data) <- c("ID", "group")

#6. Adding library size (=column sums)
DT_meta_data <- DT_meta_data[,library.size:=colSums(DT_read_count[,-(1:2)])]

#7. Adding normalisation factor (=1 initially)
DT_meta_data <- DT_meta_data[,norm.factor:=1]

#8. Defining factor variables
factor_vars <- c("ID", "group")
DT_meta_data[,factor_vars] <- DT_meta_data[,lapply(.SD, factor), .SDcols=factor_vars]

###SECTION OUTPUT
#Table with dataset characteristics
pander(data.table(Characteristic=c("Samples (n):","Groups (n):","Unique ENSEMBL IDs (n):"), Value= c(ncol(DT_read_count[,-(1:2)]), length(unique(DT_meta_data[,group])), nrow(DT_read_count))), justify=c("left", "left"))
```

***
# Data Pre-Processing
## Transforming from raw scale and removing lowly expressed genes

**Background:** The expression of a gene must reach a certain threshold for it to be translated into a protein. Translation into a protein is a prerequiste for a gene to have any biological function. Thus, genes with low number of read counts across samples are probably not differentially expressed and should be removed. However, a greater sequencing depth (i.e. a larger library size) will result in a higher read count, thus introducing a bias to the DGE analysis. Therefore, prior to filtering, raw counts are transformed into counts per million (CPM) which accounts for the difference in library size. 

**Transformation:** Raw counts are transformed into CPM by dividing each count with the sum of the column (i.e. the library size) and then multiplying by 1e6. Log-CPM is calculated by taking log2 (raw count + 0.25).

**Filtering:** Lowly expressed genes are removed from the count matrix by filtering. A gene is defined as highly expressed if CPM>1 for at least three samples. Three samples was chosen since it is equal to the smallest group size (which is equal between groups in this case).   

**Fig 1. Density of log-CPM values pre -and post filtering**

```{r echo=F, warning=F, message=F, error=F, fig.height=4, fig.width=12}
#1. Creating log CPM matrix 
DT_lcpm_unfiltered <- data.table(cpm(DT_read_count[,-c(1:2)], log=T, lib.size = colSums(DT_read_count[,-c(1:2)])))

#2. Filtering out lowly expressed genes from read_count_matrix
DT_read_count_filtered <- DT_read_count[rowSums(DT_lcpm_unfiltered>0)>=3]

#3. Calculating log cpm matrix 
DT_lcpm <- cpm(DT_read_count_filtered[,-c(1:2)], log=T, lib.size = colSums(DT_read_count_filtered[,-c(1:2)]))

#4. Melting data for plotting
lcpm_unfiltered_plotdata <- suppressWarnings(melt.data.table(data.table(DT_lcpm_unfiltered), variable.name="sample", value.name = "lcpm"))
lcpm_filtered_plotdata <- suppressWarnings(melt.data.table(data.table(DT_lcpm), variable.name="sample", value.name = "lcpm"))

#5. Plotting function
logCPM_density_plot_function <- function(plot.data, type, legend.type){
  logCPM_density_plot_out <- ggplot(plot.data, aes(x=lcpm, color=sample))+
  geom_line(stat="density", size=1.25)+
  geom_vline(xintercept=0, linetype=2)+

  scale_x_continuous(breaks=seq(-10,16,2), limits=c(-8,16))+
  scale_y_continuous(breaks=seq(0,0.6,0.05), limits=c(0,0.6))+
  scale_color_manual(values=diverge_hcl(22, c=100, l=c(50,90), power=1), name="Sample")+
  annotate("text", x=5, y=0.55, label=type, size=7.5, alpha=0.6)+
  annotate("text", x=5, y=0.5, label=paste("Genes (n):", toString(unique(plot.data[,.N, by="sample"][,N]))), fontface=2, size=4)+
  theme(legend.position=legend.type, axis.title = element_blank())
  
  if(type =="RAW"){
    logCPM_density_plot_out <- logCPM_density_plot_out + annotate("text", x=-8, y=0.6, label="A", size=7.5, fontface=2) 
  } else if(type=="FILTERED"){
    logCPM_density_plot_out <- logCPM_density_plot_out + annotate("text", x=-8, y=0.6, label="B", size=7.5, fontface=2)
  }

  return(logCPM_density_plot_out)  
}

density_raw_plot <- logCPM_density_plot_function(lcpm_unfiltered_plotdata, "RAW","right")
density_legend <- get_legend(density_raw_plot)
density_raw_plot <- logCPM_density_plot_function(lcpm_unfiltered_plotdata, "RAW","none")
density_filtered_plot <- logCPM_density_plot_function(lcpm_filtered_plotdata, "FILTERED","none")

###SECTION OUTPUT
grid.arrange(density_raw_plot, density_filtered_plot, ncol=2, widths=c(3,3), bottom=textGrob("log-CPM", gp=gpar(fontsize=17, fontface="bold")), left=textGrob("Density", gp=gpar(fontsize=17, fontface="bold"), rot=90))

```

**Fig 1.** _Figure reports the density of log-CPM for every sample (by color) pre -and post filtering of lowly expressed genes. Filtering is conducted using log-CPM values. Vertical dashed line represents the cut off (log-CPM=0). The figure shows a distinct shift of the density from below the threshold (Fig 1A) to above the threshold (Fig 1B)._  

***
##Normalizing gene expression distributions

**Background:** The read count is affected by: 1) the gene expression and 2) the sequencing depth. The sequencing depth equals the library size. The library size is defined as the sum of counts for each sample (i.e. column sum). The counts per sample represent the relative abundance of each gene. Highly expressed genes can consume a substantial proportion of the library size thus making the other genes seem underexpressed. Therefore, normalization is conducted in order to ensure that the distribution of the expression is similar for each sample. All samples should have a smiliar range and distribution of expression (log-CPM). 

**Normalization:** Scaling factors are calculated using the trimmed mean of M-values (TMM). The algorithm finds a set of scaling factors which minimizes the log-fold change between the samples. Scaling factors >1 downscale the counts while scaling factors <1 scale the counts upwards. The effective library size is then obtained by taking the product of the original library size and the scaling factor for each sample respectively.  

```{r echo=F, warning=F, message=F, error=F}
############## NORMALISING GENE EXPRESSION DISTRIBUTIONS #############
```

```{r echo=F, warning=F, message=F, error=F}
#1. Calculating norm.factors using TMM method and adding to meta_data
DT_meta_data <- DT_meta_data[,norm.factor.tmm:=calcNormFactors(DT_read_count_filtered[,-(1:2)], method = "TMM")]

#2. Calculating adjusted library sizes in meta_data
DT_meta_data <- DT_meta_data[,effective.library.size:=library.size*norm.factor.tmm]
```

**Fig 2. Distribution of log-CPM pre -and post normalization**

```{r echo=F, warning=F, message=F, error=F, fig.height=5, fig.width=12}
#1. Calculating log2 of read_count_matrix with unadjusted and adjusted library size respectively
lcpm_temp_notNormalised <- cpm(DT_read_count_filtered[,-(1:2)], log=T, lib.size = DT_meta_data[,library.size])
lcpm_temp <- cpm(DT_read_count_filtered[,-(1:2)], log=T, lib.size = DT_meta_data[,effective.library.size])

#2. Adding id columns and creating data.tables
DT_lcpm_notNormalised <- data.table(DT_read_count_filtered[,c(1:2)], lcpm_temp_notNormalised)
DT_lcpm <- data.table(DT_read_count_filtered[,c(1:2)], lcpm_temp)

#3. Creating plotting data
DT_lcpm_notNormalised_melt <- melt.data.table(DT_lcpm_notNormalised, id.vars=c("ENSEMBL_ID", "SYMBOL"), variable.name = "sample")
DT_lcpm_melt <- melt.data.table(DT_lcpm, id.vars=c("ENSEMBL_ID", "SYMBOL"), variable.name = "sample")

#4. Plotting function for gene expression distribution of 
log_cpm_distribution_function <- function(dataset, type){
  log_cpm_distribution_plot <- ggplot(dataset, aes(sample,value, color=sample))+
  geom_jitter(DT_lcpm_notNormalised_melt[,.(value=sample(value,10000)), by="sample"], mapping=aes(sample, value),alpha=0.05)+
  geom_boxplot(size=1, color="black", alpha=0)+

  scale_y_continuous(limits=c(-8,20), breaks=seq(-10,20,2))+
  scale_fill_manual(values=diverge_hcl(22, c=100, l=c(50,90), power=1), name="Sample:")+
  scale_color_manual(values=diverge_hcl(22, c=100, l=c(50,90), power=1), name="Sample:")+
    
  theme(legend.position = "none", axis.title = element_blank(), axis.text.x = element_text(size=10, angle = 90))+
  annotate("text", x=11.5, y=18, label=type, size=7.5, alpha=0.6)
  
  if(type =="RAW"){
    log_cpm_distribution_plot <- log_cpm_distribution_plot + annotate("text", x=2, y=20, label="A", size=7.5, fontface=2)
  } else if(type=="NORMALIZED"){
    log_cpm_distribution_plot <- log_cpm_distribution_plot + annotate("text", x=2, y=20, label="B", size=7.5, fontface=2)
  }

  return(log_cpm_distribution_plot)
  
}

###SECTION OUTPUT
grid.arrange(log_cpm_distribution_function(DT_lcpm_notNormalised_melt, "RAW"), log_cpm_distribution_function(DT_lcpm_melt, "NORMALIZED"), ncol=2, bottom=textGrob("Sample", gp=gpar(fontsize=17, fontface="bold")), left=textGrob("log-CPM", gp=gpar(fontsize=17, fontface="bold"), rot=90))
```

**Fig 2.** _Figure reports the distribution of gene expression (log-CPM) for each sample. Fig 2A reports the distribution prior to normalization while Fig 2B reports the distribution following normalization of library sizes using trimmed means of M-values. Boxplots are based on all log-CPM values while points represent a random sample of 1e4 observations (due to processing time issues). The difference in the distribution of log-CPM using original and effective library sizes is minor but adjusted for._

***

```{r echo=F, warning=F, message=F, error=F}
########################################### UNSUPERVISED LEARNING 1: PCA ############################################
```

# Unsupervised Clustering 1: PCA

**Principal component analysis (PCA):** A PCA aims at producing a low-dimensional representation of the dataset. The principal components are each normalized linear combinations of a set of features constructed with loadings with the intention to achieve maximal variance. Normalized means that the sum of squared loadings equals one. Furthermore, the principal components are constructed to be uncorrelated to each other.  

**Fig 3. Variance explained by principal components based on the 500 genes with highest variance**

```{r echo=F, warning=F, message=F, error=F, fig.height=6, fig.width=12}
#1. Calculating the variance for each gene
gene_variance <- data.table(DT_lcpm[,c(1:2)], variance=apply(DT_lcpm[,-(1:2)], 1, var))

#2. Selecting the 500 genes with highest variance 
gene_variance_top500 <- gene_variance[order(-variance)][1:500]

#3. Calculating principal components for the genes with highest variance (top 500) from DT_lcpm
setkey(DT_lcpm, ENSEMBL_ID)
DT_principal_comp_raw <- prcomp(t(DT_lcpm[ENSEMBL_ID %in% gene_variance_top500[,ENSEMBL_ID],-(1:2)]))
DT_principal_comp_summary <- data.table(sd=summary(DT_principal_comp_raw)$sdev)

#4. Subsetting data for plotting
DT_principal_comp <- data.table(RH.index=factor(rownames(DT_principal_comp_raw$x)), DT_principal_comp_raw$x)

#5. Merging with meta_data 
DT_principal_comp <- merge(DT_principal_comp, DT_meta_data[,c(1:3)], by.x="RH.index", by.y="ID")

#6. Calculating proportion of explained variance 
DT_principal_comp_summary <- DT_principal_comp_summary[,var:=sd**2][,var.prop:=var/sum(var)][,var.prop.cumsum:=cumsum(var.prop)]

PCA_plot_prop.var_function <- function(dataset, yvariable,color){
  explained_var_plot <- ggplot(dataset, aes(1:22,get(yvariable)))+
  geom_bar(stat="identity", fill=brewer.pal(11, "RdBu")[color], alpha=0.9, width=0.7)+
  geom_point(size=4, shape=18)+
  geom_line(linetype=2, size=1.5)+
  geom_text(aes(label=format(round(get(yvariable),2), digits = 2)), vjust=-1, fontface="bold", size=4)+
  
  scale_x_discrete(limits=seq(1,22,1))+
  scale_y_continuous(breaks=seq(0,1,0.1), limits=c(0,1.1))+
  theme(axis.title= element_blank())
  
  if(yvariable=="var.prop"){
    explained_var_plot <- explained_var_plot + annotate("text", x=1, y=1.1, label="A", fontface=2, size=7.5)+ annotate("text", x=11.5, y=1.1, label="PROPORTIONAL", size=7.5, alpha=0.6)
  } else if(yvariable=="var.prop.cumsum"){
    explained_var_plot <- explained_var_plot + annotate("text", x=1, y=1.1, label="B", fontface=2, size=7.5)+annotate("text", x=11.5, y=1.1, label="CUMULATIVE", size=7.5, alpha=0.6)
  }
  
  return(explained_var_plot)
}

#8. Subsetting log CPM using the 500 genes with highest variance
DT_pca_sim <- DT_lcpm[ENSEMBL_ID %in% gene_variance_top500[,ENSEMBL_ID],-(1:2)]

#9. Boostrapping proportion of variance for each principal component   
DT_pca_boot_conf <- boot(DT_pca_sim, function(dataset, b){summary(prcomp(t(dataset[b])))$importance[2,]},1000)

#10. Extracting 95 % confidence intervals from bootstrapped data (10 first components)
DT_pca_boot_conf_summary <- suppressWarnings(data.table(do.call(rbind, lapply(1:10, function(column){boot.ci(DT_pca_boot_conf, type="bca", index=column)$bca[(4:5)]}))))
names(DT_pca_boot_conf_summary) <- c("CI.Lower", "CI.Upper")

#11. Converting bootstrapped data into plotable data 
DT_pca_boot_conf_plotdata <- data.table(DT_pca_boot_conf$t)[, 1:10]
names(DT_pca_boot_conf_plotdata) <- names(DT_pca_boot_conf$t0)[1:10]
DT_pca_boot_conf_plotdata <- suppressWarnings(melt.data.table(DT_pca_boot_conf_plotdata, variable.name = "PC.type"))

#12. Plotting function for prop.var explained distribution
pca_boot_conf_function <- function(data.set.conf){
  pca_boot_conf_out <- ggplot(data.set.conf, aes(value, fill=PC.type))+
  geom_rect(aes(xmin=DT_pca_boot_conf_summary[1,CI.Lower], xmax=DT_pca_boot_conf_summary[1,CI.Upper], ymin=0, ymax=100), fill="grey", alpha=0.05)+
  geom_histogram(alpha=0.7, bins=40, position="identity")+
  
  scale_fill_manual(values=brewer.pal(10, "RdBu"))+
  
  theme(legend.title = element_blank(), legend.position = "right", axis.title = element_blank())
  
  if(data.set.conf[,PC.type][1]!="PC1"){
    pca_boot_conf_out <- pca_boot_conf_out + scale_x_continuous(breaks=seq(0,0.05,0.01), limits = c(0,0.08))+scale_y_continuous(breaks=seq(0,1100,100), limits=c(0,1100))+annotate("text", x=0.005, y=1100, label="B", size=7.5, fontface=2)
  } else if(data.set.conf[,PC.type][1]=="PC1"){
    pca_boot_conf_out <- pca_boot_conf_out + scale_x_continuous(breaks=seq(0.9,1,0.01))+scale_y_continuous(breaks=seq(0,110,10), limits=c(0,110))+annotate("text", x=0.755, y=110, label="A", size=7.5, fontface=2)+annotate("text", x=0.8, y=110, label=paste("95 % CI:\n",toString(round(DT_pca_boot_conf_summary[1,CI.Lower],2)), "-", round(DT_pca_boot_conf_summary[1,CI.Upper],2)), size=4, fontface=2)
  }

  return(pca_boot_conf_out)
}

###SECTION OUTPUT
grid.arrange(PCA_plot_prop.var_function(DT_principal_comp_summary,"var.prop",1),PCA_plot_prop.var_function(DT_principal_comp_summary,"var.prop.cumsum",11), ncol=2, bottom=textGrob("Principal component", gp=gpar(fontsize=17, fontface="bold")), left=textGrob("Proportion variance explained", gp=gpar(fontface="bold", fontsize=17), rot=90))

```

**Fig 3.** _Figure reports the proportion variance explained by each principal component. Fig 3A reports the proportional variance explained by each component while Fig 3B reports the cumulative variance explained by the components. It is obvious that the first principal component explains the majority of the variance while the remaining components explain only a small portion of the variance._

**Fig 4. Estimation of distribution of the variance explained by the principal components **

```{r echo=F, warning=F, message=F, error=F, fig.height=6, fig.width=12}
# grid.arrange(pca_boot_conf_function(DT_pca_boot_conf_plotdata[PC.type=="PC1"]),pca_boot_conf_function(DT_pca_boot_conf_plotdata[PC.type!="PC1"]), ncol=2, bottom=textGrob("Proportional variance explained", gp=gpar(fontsize=17, fontface="bold")),left=textGrob("Count (n)", gp=gpar(fontface="bold", fontsize=17), rot=90))

```

**Fig 4.** _Figure reports the distribution of bootstrapped proportion of variance explained by each principal component. Bootstrap is conducted using the 500 genes with the highest variance. Fig 4A reports the distribution for the first principal component while Fig 4B reports the distribution for the remaining eleven components (due to differences in magnitude). Shaded region in Fig 4A represents a bootstrapped nonparametric 95 % confidence interval. The histograms show narrow distributions which confirms the observations and conclusion in Fig 3._

**Table 2. Upper and lower bounds (95 % confidence interval) for the proportion of variance explained by principal component 1 to 11 **
```{r echo=F, warning=F, message=F, error=F, fig.height=6, fig.width=12}
kable(data.table("bound"=c("Upper bound:", "Lower bound:"),t(round(DT_pca_boot_conf_summary,3))), col.names = c(" ", paste(rep("PC", 10), 1:10, sep="")), align="c")
```

***

**Fig 5. Multidimensional scaling plot of the 500 genes with the highest variance**

```{r echo=F, warning=F, message=F, error=F, fig.height=6, fig.width=10}
#1. Creating data for ellipses
ellipse_data <- suppressWarnings(do.call(rbind,lapply(split(DT_principal_comp, DT_principal_comp[,group]), function(group.object){data.table(group=group.object[,group],with(group.object, ellipse::ellipse(cor(PC1,PC2), scale = c(sd(PC1), sd(PC2)), centre=c(mean(PC1), mean(PC2)), t=1.5)))})))

#2. Creating group_names to avoid repetition in plot
group_names <- c("MSC[in vitro]", "MSC[Naive]", "MSC[SCI]")

#3. Creating MDS plot
PCA_plot_mds <- ggplot(DT_principal_comp, aes(PC1, PC2))+
  geom_segment(aes(x=-100, xend=100, y=0, yend=0), size=0.2)+
  geom_segment(aes(x=0, xend=0, y=-15, yend=20), size=0.2)+
  geom_polygon(ellipse_data, mapping=aes(x,y, fill=group), alpha=0.2, show.legend = F)+
  geom_point(aes(color=group, shape=group), size=7, alpha=0.8)+

  xlab("Principal component 1")+
  ylab("Principal component 2")+
  
  scale_color_manual(values=brewer.pal(11,"RdBu")[c(1,2,10)], labels=group_names)+
  scale_shape_manual(values=c(18,17,16), labels=group_names)+
  scale_fill_manual(values=brewer.pal(11,"RdBu")[c(1,2,10)], labels=group_names)+
  scale_x_continuous(breaks=seq(-100, 150, 20))+
  scale_y_continuous(breaks=seq(-20, 30, 2))+
  
  theme(legend.title = element_blank(), legend.position = "bottom", legend.text=element_text(size=20), legend.justification = "center", axis.title = element_text(size=22, face="bold"), axis.line = element_blank(), axis.ticks = element_blank())+
  
  annotate("text", x=-30, y=13, label="MSC[Naive]", size=6, fontface=2)+
  annotate("text", x=-30, y=-8, label="MSC[SCI]", size=6, fontface=2)+
  annotate("text", x=100, y=6, label="MSC[in vitro]", size=6, fontface=2)+
  
  annotate(geom="text", x=0, y=0, label="PCA", size=10, fontface=2, alpha=0.7)

###SECTION OUTPUT
PCA_plot_mds
# ggsave("PCA_plot_mds.jpg", PCA_plot_mds, dpi=1000, height = 7, width=14)

```

**Fig 5.** _Figure reports the distribution of the samples along the first and second principal component. Study groups are indicated with ellipses. Ellipses represent a 95 % confidence interval based on the samples within each group. There is a distinct separation between the four study groups. Uninjured samples separate from the three other study groups which contain animals exposed to SCI. The syngeneic and allogenic groups do form an "venn diagram like" pattern in relation to the injury only group in the sense that they both have one animal which overlaps with the injury control study group._

# K-means clustering of boostrapped principal components 

**Fig 6. K means clustering (4 groups) of 1000 boostrap replicates for the first -and second principal component for the 500 genes with the highest variance** 

```{r echo=F, warning=F, message=F, error=F, fig.height=6, fig.width=10}
#1. Bootstrap function: boostrap from top 500 genes with highest variance and calculate PC1 and PC2 
pca_simulation_function <- function(dataset, run){
  sim_data <- dataset[sample(1:500, replace = T)]
  sim_prcomp_raw <- prcomp(t(sim_data))$x[,(1:2)]
  sim_prcomp <- data.table(ID=rownames(sim_prcomp_raw),sim_prcomp_raw)
  return(sim_prcomp)
}

#2. Calling boostrap function, creating data table and merging with group name 
DT_pca_boot <- do.call(rbind, lapply(1:1000, function(dataset,i){pca_simulation_function(DT_pca_sim,i)}))
DT_pca_boot <- merge(DT_pca_boot, DT_meta_data[,.(ID, group)], by="ID")

#3. Adding K-means clustering
DT_pca_boot_kmeans <- kmeans(DT_pca_boot[,c(2,3)], 3, nstart=20)
DT_pca_boot <- DT_pca_boot[,k.mean.cluster:=factor(DT_pca_boot_kmeans$cluster)]

#4. K means clustering on original samples (raw data, not boostrapped)
DT_pca_kmean_sample <- DT_principal_comp[,.(PC1, PC2, RH.index, group)]
DT_pca_kmean_sample <- DT_pca_kmean_sample[,k.mean.group:=factor(kmeans(DT_principal_comp[,.(PC1,PC2)], 4, nstart=20)$cluster)]

#5. Creating ellipse data for bootstraped PCA data
ellipse_data_boot <- do.call(rbind,lapply(split(DT_pca_boot, DT_pca_boot[,k.mean.cluster]), function(cluster){data.table(cluster=rep(unique(cluster[,k.mean.cluster]),100), with(cluster, (ellipse::ellipse(cor(PC1,PC2), scale = c(sd(PC1), sd(PC2)), centre=c(mean(PC1), mean(PC2))))))}))

#6. Plotting function for bootstrapped PCA
color_palette <- brewer.pal(11, "RdBu")[c(1,2,10)]

PCA_sim_plot_function <- function(dataset, group.var){

  PCA_sim_plot_out <- ggplot(dataset, aes(PC1, PC2))+
  geom_segment(aes(x=-100, xend=100, y=0, yend=0), size=0.2)+
  geom_segment(aes(x=0, xend=0, y=-25, yend=25), size=0.2)+
  geom_polygon(ellipse_data_boot, mapping=aes(x,y, fill=cluster), alpha=0.2, show.legend = F)+
  geom_jitter(aes(color=get(group.var)), alpha=0.2, size=2, width=1.5, show.legend = F)+
  geom_point(DT_pca_kmean_sample, mapping=aes(PC1, PC2, shape=group), size=5)+
  
  xlab("Principal component 1")+
  ylab("Principal component 2")+

  scale_color_manual(values=color_palette)+
  scale_fill_manual(values=color_palette)+
  scale_shape_manual(values=c(18,17,16), labels=group_names)+
  scale_x_continuous(breaks=seq(-100, 150, 20))+
  scale_y_continuous(breaks=seq(-30, 35, 5))+
  
  theme(legend.title = element_blank(), legend.position = "bottom", legend.text = element_text(size=20), legend.justification = "center", axis.title = element_text(size=22, face="bold"), axis.line = element_blank(), axis.ticks = element_blank())+
    
  annotate("text", x=-90, y=20, label="K1", fontface=4, size=6)+
  annotate("text", x=-35, y=20, label="K2", fontface=4, size=6)+
  annotate("text", x=100, y=5, label="K3", fontface=4, size=6)+
    
  annotate(geom="text", x=0, y=0, label="PCA", fontface=2, size=10, alpha=0.7)

  return(PCA_sim_plot_out)
  
}

###SECTION OUTPUT
PCA_sim_plot_function(DT_pca_boot, "k.mean.cluster")
# ggsave("PCA_plot_boot.jpg",PCA_sim_plot_function(DT_pca_boot, "k.mean.cluster"), dpi=1000, width=14, height=7)

```

**Fig 6.** _Figure reports the first and second principal component for 1000 bootstrapped replicates per sample based on the 500 genes with highest variance. K means clustering with 4 groups and 20 starts was conducted on both the bootstrapped data. Ellipses are centered around the mean value of the botstrapped values for each cluster and represent a 95 % confidence interval for the data in each cluster. The clustering confirms the hypothesis postulated in Fig 5._ 

# t-distributed Stochastic Neighbour Embedding

*Explanation

```{r echo=F, warning=F, message=F, error=F, fig.height=6, fig.width=10}
#1. Dimensionality reduction using t-SNE 
DT_tSNE_raw <- t(DT_lcpm[ENSEMBL_ID %in% gene_variance_top500[,ENSEMBL_ID],-(1:2)])
DT_tSNE <-  Rtsne(as.matrix(DT_tSNE_raw), check_duplicates=FALSE, pca=TRUE, perplexity=3, theta=0.5, dims=2)
tSNE_plot_data <- data.table(DT_tSNE$Y)  

#2. K-Means clustering
tSNE_kmeans=kmeans(scale(tSNE_plot_data), 3)  
tSNE_plot_data[,k_group:=factor(tSNE_kmeans$cluster)]
tSNE_plot_data[,`:=`(group=DT_meta_data[, group], ID=DT_meta_data[, ID])]

tSNE_plot <- ggplot(tSNE_plot_data, aes(V1, V2, color=k_group, shape=group))+
  scale_color_manual(values=brewer.pal(11,"RdBu")[c(1,2,10)], labels=c("K1", "K2", "K3"))+
  scale_shape_manual(values=c(18,17,16), labels=group_names)+
  geom_point(size=7, alpha=0.7)+
  geom_text(aes(label=ID), nudge_x = 7, show.legend = F)+
  
  xlab("Variable 1")+
  ylab("Variable 2")+
  
  theme(legend.title = element_blank(), legend.position = "bottom", legend.text=element_text(size=20), legend.justification = "center", axis.title = element_blank(), axis.text = element_blank(), axis.line = element_blank(), axis.ticks = element_blank())+
  
  annotate(geom="text", x=0, y=0, label="t-SNE", size=10, fontface=2, alpha=0.7)+
  geom_segment(aes(x=-100, xend=100, y=0, yend=0), color="black", size=0.2)+
  geom_segment(aes(x=0, xend=0, y=-100, yend=100), color="black", size=0.2)

```

**Figure x.** _Perplexity=3, theta=0.5._


```{r echo=F, warning=F, message=F, error=F, fig.height=6, fig.width=10}
 
#     + Expectation maximisation (EM)
#         http://rstudio-pubs-static.s3.amazonaws.com/154174_78c021bc71ab42f8add0b2966938a3b8.html
#     + Affinity propagation 
#         https://cran.r-project.org/web/packages/apcluster/vignettes/apcluster.pdf
#     + Mean-shift
#         https://cran.r-project.org/web/packages/MeanShift/vignettes/MeanShift-clustering.html
#     + Spectral clustering
#         http://www.di.fc.ul.pt/~jpn/r/spectralclustering/spectralclustering.html
#     + Hierarchical
#         Done: 

#Do common plot function -> call and present in grid.arrange


```


**Fig 7. Top 10 positive and negative loadings for the first -and second principal component**

```{r echo=F, warning=F, message=F, error=F, fig.height=5, fig.width=12}
#1. Selecting PC1 and PC2 and adding gene names 
DT_loadings <- data.table(SYMBOL=gene_variance_top500[,SYMBOL], DT_principal_comp_raw$rotation[,(1:2)])

#2. Creating table data
DT_loadings_sub_function <- function(data.load, pc.type, n){
  load_out <- data.load[,.(SYMBOL, get(pc.type))][order(V2)]
  load_out <- rbind(tail(load_out, n), head(load_out, n))
  load_out[,"V2"] <- round(load_out[, V2],3)
  load_out <- load_out[ ,PC.type:=pc.type]
  names(load_out) <- c("Gene", "PC.value", "PC.type")
  return(load_out)  
}

DT_loadings_plotdata <- rbind(DT_loadings_sub_function(DT_loadings[!is.na(SYMBOL)],"PC1", 10), DT_loadings_sub_function(DT_loadings[!is.na(SYMBOL)],"PC2", 10))

#3. Adding a type variable for plotting purposes
DT_loadings_plotdata <- DT_loadings_plotdata[,sign.type:=factor(ifelse(PC.value>0,"pos","neg"))]

#4. Plotting function
DT_loadings_plot_function <- function(data.set.loading, pc.type){
  data.set.loading <- data.set.loading[PC.type==pc.type]
  data.set.loading[,"Gene"] <- factor(data.set.loading[, Gene], levels=unique(data.set.loading[,Gene]))
  
  DT_loadings_out <- ggplot(data.set.loading, aes(Gene, PC.value, fill=PC.type))+
  geom_bar(aes(alpha=sign.type), stat="identity", show.legend = F)+
  geom_text(data.set.loading[PC.value>0], mapping=aes(label=round(PC.value,2)), hjust=-0.5, fontface=2, size=5)+
  geom_text(data.set.loading[PC.value<0], mapping=aes(label=round(PC.value,2)), hjust=1.5, fontface=2, size=5)+
  geom_segment(aes(x=0, xend=20, y=0, yend=0), size=2, linetype=2)+
  coord_flip()+
  
  scale_y_continuous(breaks=seq(-0.5, 0.5, 0.05), limits=c(-0.3, 0.3))+
  scale_alpha_manual(values=c(0.7,0.9))+
  
  theme(axis.text.x = element_text(size=12), axis.title.x = element_text(face="bold", size=22), axis.title.y = element_blank(), axis.text.y = element_text(size=15))
  
  if(pc.type=="PC1"){
    DT_loadings_out <- DT_loadings_out+scale_fill_manual(values=brewer.pal(11, "RdBu")[1])+annotate("text", x=20, y=-0.25, label="A", size=7.5, fontface=2) + ylab("Principal component 1")
  } else if(pc.type=="PC2"){
    DT_loadings_out <- DT_loadings_out+scale_fill_manual(values=brewer.pal(11, "RdBu")[11])+annotate("text", x=20, y=-0.25, label="B", size=7.5, fontface=2)+ylab("Principal component 2")
  }
  
  return(DT_loadings_out)
}

###SECTION OUTPUT
grid.arrange(DT_loadings_plot_function(DT_loadings_plotdata, "PC1"), DT_loadings_plot_function(DT_loadings_plotdata,"PC2"), ncol=2, left=textGrob("Gene", gp=gpar(fontface="bold", fontsize=17), rot=90))

# #Saving loadings plot for PC1
# ggsave("loadings_plot.jpg",DT_loadings_plot_function(DT_loadings_plotdata, "PC1"), dpi=1000, width=14, height=7)

```

**Fig 7.** _Figure reports the top 10 positive and negative loadings for the first -and second principal component._ 

**Fig 8. Hierarchical clustering of samples based on 1000 genes with highest variance** 

```{r echo=F, warning=F, message=F, error=F, fig.width=12, fig.height=5}
#1. Selecting the 1000 genes with highest variance 
gene_variance_top1000 <- gene_variance[order(-variance)][1:1000]

#2. Creating a dissimilarity structure for the 100 genes with highest variance
setkey(DT_lcpm, ENSEMBL_ID)
DT_dist <- dist(t(DT_lcpm[ENSEMBL_ID %in% gene_variance_top1000[,ENSEMBL_ID],-(1:2)]))

#3. Hierarchicla clustering on on the dissimilarity structure
DT_hclust <- hclust(DT_dist)

#4. Plotting the hierarchical clustering (with labels and adding color by group)
myplclust(DT_hclust, labels = paste(DT_meta_data[,group]," ","(", DT_meta_data[,ID],")", sep=""), main="", ylab="", lab.col=brewer.pal(11, "RdBu")[c(1,2,10)][as.numeric(DT_meta_data[,group])], font=2, cex=1, hang=0.05)

# #Saving
# jpeg('PCA_hierarchical.jpg',
#      width=1400,
#      height=700,
#      quality=1000)
# myplclust(DT_hclust, labels = paste(DT_meta_data[,group]," ","(", DT_meta_data[,ID],")", sep=""), main="", ylab="", lab.col=brewer.pal(11, "RdBu")[c(1,2,10,11)][as.numeric(DT_meta_data[,group])], font=2, cex=1, hang=0.05)
# dev.off()

```

**Fig 8.** _Figure reports a dendrogram which illustrates hierarchical clustering of samples based on the 1000 genes with the highest variance._ 

***
#Negative Binominal Dispersions by Weighted Likelihood Empirical Bayes  

**Fig 9. Cox-Reid profile-adjusted likelihood estimated tagwise, common and trended dispersions**

```{r echo=F, warning=F, message=F, error=F, fig.width=12, fig.height=5} 
#1. Setting up a design matrix (a dummy matrix indicating which group each sample belongs to)
DT_design <- model.matrix(~0+DT_meta_data[,group])
colnames(DT_design) <- c("MSCsci", "MSCnaive", "MSCinvitro")

#2. Estimating dispersions (common, trended and tagwise)
DT_dispersion <- estimateDisp(DGEList(DT_read_count_filtered[,-(1:2)], lib.size = DT_meta_data[,effective.library.size]), design = DT_design, trend.method = "loess")

DT_dispersion_tagwise <- data.table(DT_dispersion$AveLogCPM, DT_dispersion$tagwise.dispersion)
names(DT_dispersion_tagwise) <- c("average.logCPM", "tagwise")

#3. Plotting dispersions
plot_dispersion <- ggplot(DT_dispersion_tagwise, aes(average.logCPM, tagwise))+
  geom_point(alpha=0.3)+
  geom_smooth(color="dodgerblue2", se=F, span=2, method="loess", size=1.2)+
  geom_segment(aes(x=-1.25, xend=14.5, y=DT_dispersion$common.dispersion, yend=DT_dispersion$common.dispersion), color="red", size=1.25)+

  xlab("Average log-CPM")+
  ylab("Biological coefficient of variation (BCV)")+
  
  scale_y_continuous(limits=c(-0.1,1), breaks=seq(-0.1,1,0.1))+
  scale_x_continuous(breaks=seq(-10,15,1))+
  
  annotate("text", x=12.5, y=0.9, label="Common", fontface=2, color="red")+
  annotate("text", x=12.5, y=0.85, label="Trended", fontface=2, color="dodgerblue2")+
  annotate("text", x=12.5, y=0.8, label="Tagwise", fontface=2, color="black")+
  
  theme(axis.title.x = element_text(face="bold", size=17), axis.title.y = element_text(face="bold", size=14))
  
####SECION OUTPUT
plot_dispersion

```

**Fig 9. ** _Figure reports tagwise, common and trended dispersions._

***

```{r echo=F, warning=F, message=F, error=F}
########################################### Removing heteroscedasticity ############################################
```

# Linear Modelling and Empirical Bayes Moderation Using Precision Weights 

**Background:** The variance of raw counts is not independent of its mean. Furthermore, the variance of raw counts increases with the count size (opposite is true for log-counts). 

**Voom transformation:** Acronym for mean-variance modelling at the observational level. The mean-variance relationship is estimated in the data which is then used for computing precision weights for each gene. The precision weights are then implemented in the linear modelling in order to adjust for heteroscedasticity. Estimation of precision weights is done as follows: 1) log-CPM=log2(raw count + 0.5), 2) a linear modelled is fitted to each gene, 3) lowess function is fitted to the scatterplot between average log-CPM and sqrt(st.dev), 4) the variance of the log-CPM for each gene is predicted using the lowess trend line 5) the inverse of the variance for each log-CPM value is the precision weight.     

**Empirical Bayes moderation of standard error:** Ranks genes in order of evidence of differential expression. 

**Fig 10. Mean-variance relationship pre -and post voom transformation**

```{r echo=F, warning=F, message=F, error=F, fig.height=4, fig.width=12}
#1. Setting up a contrast matrix for pairwise comparisons
DT_contrast <- makeContrasts(
  MSCsci_MSCnaive = MSCsci-MSCnaive,
  MSCsci_MSCinvitro = MSCsci-MSCinvitro,
  MSCnaive_MSCinvitro = MSCnaive-MSCinvitro,
  levels = colnames(DT_design)
)

#2. Applying voom (precision weights modelling of mean-variance relationship)
DT_voom_raw <- voom(DT_read_count_filtered[,-(1:2)], lib.size = DT_meta_data[,effective.library.size], save.plot = T)

#3. Fit a linear model for each gene
DT_vfit <- lmFit(DT_voom_raw$E, design = DT_design, weights = DT_voom_raw$weights)

#4. Calculate coefficients and standard errors for each linear model (i.e. gene)
DT_vfit <- contrasts.fit(DT_vfit, contrasts = DT_contrast)

#5. Calculate moderated F & t-statistics, log odds of differential expression using emiprical Bayes moderation for each linear model (i.e. gene)
DT_efit <- eBayes(DT_vfit)

#6. Creating a DT_efit object using limma-trend instead of voom trend
DT_vfit_limmaTrend <- lmFit(DT_lcpm[,-(1:2)], design=DT_design)
DT_vfit_limmaTrend <- contrasts.fit(DT_vfit_limmaTrend, contrasts = DT_contrast)
DT_efit_limmaTrend <- eBayes(DT_vfit_limmaTrend)

#7. Plotting mean-variance plot for voom
DT_voom_plotdata <- data.table(log.cpm=DT_voom_raw$voom.xy$x,quarter.var=DT_voom_raw$voom.xy$y)
DT_efit_plotdata <- data.table(Amean=DT_efit$Amean, log2.sigma=log2(DT_efit$sigma))

voom_plot <- ggplot(DT_voom_plotdata, aes(log.cpm, quarter.var))+
  geom_point(alpha=0.3)+
  geom_smooth(method="loess", color="red", se=F, linetype=2, size=1.5)+
  
    ylab("Sqrt (St.Dev)")+
  
  scale_x_continuous(breaks=seq(0,18,2))+
  scale_y_continuous(breaks=seq(0,3,0.5), limits=c(0.25,2.5))+

  theme(axis.title.y = element_text(face="bold", size=17), axis.title.x = element_blank())+
  annotate("text", x=0, y=2.5, label="A", size=7.5, fontface=2)

bayes_plot <- ggplot(DT_efit_plotdata, aes(Amean, log2.sigma))+
  geom_point(alpha=0.3)+
  geom_smooth(method="loess", color="red", se=F, linetype=2, size=1.5, span=1.25)+
  geom_segment(aes(x=-3.5, xend=14.5, y=mean(DT_efit_plotdata[,log2.sigma], na.rm=T), yend=mean(DT_efit_plotdata[,log2.sigma], na.rm=T)), color="dodgerblue2", size=1.5, alpha=0.5)+
  
  ylab("log2 (St.Dev)")+
  
  scale_x_continuous(breaks=seq(-2,14,2))+
  scale_y_continuous(breaks=seq(-4,4,0.5), limits=c(-2.5,2.5))+

  theme(axis.title.y = element_text(face="bold", size=17), axis.title.x = element_blank())+
  annotate("text", x=-3.5, y=2.5, label="B", size=7.5, fontface=2)

###SECTION OUTPUT
grid.arrange(voom_plot, bayes_plot, ncol=2, nrow=1, bottom=textGrob("Average log-CPM", gp=gpar(fontsize=17, fontface="bold")))
```

**Fig 10.** _Figure reports the mean-variance relationship pre -and post application of the voom function. Fig 9A reports the average log-CPM against the quarter root of the variance. Fig 9B reports average log-CPM against the log2(st.dev). Blue line reports the average log2(st.dev). The red line is a linear trend fitted to the black dots. Each black dot represents a gene. Fig 9A illustrates that the variance is decresing when the average expression is increasing. In Fig 9B the dependency is removed and the mean variance is unchanged when the average expression increases._      

***

# Differential Gene Expression
**Determining significant gene differential expression for a contrast:** A simple Bayesian model is used for moderating standard errors across genes (squeeze them towards a common value) and producing moderated t-statistics. These moderated t-statistics are used for significance analysis. Moderated t-statistics have a higher degree of freedom in comparison to usual t-statistics due to the increase in reliability resulting from the smoothening of standard errors. P-values are adjusted for multiple testing using Benjamini and Hochberg's method to control for false discovery rate (FDR). 

**Fig 11. Number of differentially expressed genes for each contrast**

```{r echo=F, warning=F, message=F, error=F, fig.show='hide'}
#1. Summarizing the number of up - and downregulated differentially expressed genes
DT_dge <- decideTests(DT_efit, adjust.method = "BH")

#2. Converting DT_dge into logical (-1 and 1 is TRUE and 0 is FALSE) 
venn_data_logical <- do.call(cbind,lapply(data.table(DT_dge), function(column){column!=0}))

#3. Function for retrieving data to add to venndiagram
venn_data_function <- function(data.set, c1=NULL, c2=NULL, c3=NULL){
  out <- sum(rowSums(data.set[,c(c1, c2, c3)]) %in% length(c(c1, c2, c3)))
  return(out)
}

#4. Venn diagram: injured only 
venn_plot <- invisible(draw.triple.venn(sum(venn_data_logical[,1]), 
               sum(venn_data_logical[,2]), 
               sum(venn_data_logical[,3]), 
               venn_data_function(venn_data_logical,1,2),
               venn_data_function(venn_data_logical,2,3),
               venn_data_function(venn_data_logical,1,3),
               venn_data_function(venn_data_logical,1,2,3),
               category=c("MSC[SCI] - MSC[naive]", "MSC[SCI] - MSC[invitro]", "MSC[naive] - MSC[invitro]"),
               lwd=c(2,2,2),
               fill=brewer.pal(11,"RdBu")[c(2,4,9)],
               alpha=0.7,
               cex=2,
               cat.cex=1.5,
               cat.col= brewer.pal(11,"RdBu")[c(2,4,9)],
               cat.fontface=2,
               cat.just=list(c(0.6, -6), c(0.5,-6), c(0.5, 6)),
               cat.default.pos = "text",
               margin=c(0.2)))

```

```{r echo=F, warning=F, message=F, error=F, fig.width=6, fig.height=6, fig.align='center'}
###SECTION OUTPUT
grid.arrange(arrangeGrob(gTree(children=venn_plot)))
```

**Fig 11.** _Figure reports venn diagrams containing the number of differentially expressed genes for each contrast._

**Table 3. Number of differentially over -and under-expressed genes for each contrast**

```{r echo=F, warning=F, message=F, error=F, fig.width=15, fig.height=6, fig.align='center'}
#Summary table
DT_dge_summary <- as.data.frame.matrix(summary(DT_dge))
rownames(DT_dge_summary) <- c("Downregulated:", "No change", "Upregulated:")
kable(DT_dge_summary, col.names = c("MSC[SCI]-MSC[naive]", "MSC[SCI]-MSC[invitro]", "MSC[naive]-MSC[invitro]"), align="c")
```

**Fig 12. Mean difference -and volcano plot**

```{r echo=F, warning=F, message=F, error=F, fig.width=14, fig.height=5}
#1. Creating plotting data for mean-difference plot
DT_mean_difference <- data.table(toptable(DT_efit, coef=1, number=Inf, genelist = DT_read_count_filtered[,SYMBOL], A=DT_efit$Amean))
DT_mean_difference <- DT_mean_difference[!is.na(ID)]

#2. Plotting mean-difference
mean_difference_plot <- ggplot(DT_mean_difference, aes(AveExpr,logFC))+
  geom_jitter(DT_mean_difference[(logFC>(-1) & logFC<1)], mapping=aes(AveExpr, logFC), alpha=0.7, size=3)+
  geom_jitter(DT_mean_difference[(logFC<=(-1) | logFC >=1) & adj.P.Val>0.05], mapping=aes(AveExpr, logFC), color="dodgerblue4", alpha=0.8, size=3)+
  geom_jitter(DT_mean_difference[(logFC<=(-1) | logFC>=1) & adj.P.Val<0.05], mapping=aes(AveExpr, logFC), color="red", alpha=0.5, size=3)+
  geom_segment(aes(x=-5, xend=15, y=-1,yend=-1), size=1.5, color="dodgerblue2", linetype=2)+
  geom_segment(aes(x=-5, xend=15, y=1,yend=1), size=1.5, color="dodgerblue2", linetype=2)+
  
  annotate("text", x=12, y=5.5, label=nrow(DT_mean_difference[logFC >=1 & adj.P.Val>0.05]), color="dodgerblue4", fontface=2, alpha=0.8, size=4.5)+
    annotate("text", x=12, y=-5.5, label=(nrow(DT_mean_difference[logFC<=-1 & adj.P.Val>0.05])+2), color="dodgerblue4", fontface=2, alpha=0.8, size=4.5)+

  annotate("text", x=12, y=-3.5, label=(nrow(DT_mean_difference[logFC<=-1 & adj.P.Val<0.05])+2), color="red", fontface=2, alpha=0.8, size=4.5)+
  annotate("text", x=12, y=3.5, label=nrow(DT_mean_difference[logFC>=1 & adj.P.Val<0.05]), color="red", fontface=2, alpha=0.8, size=4.5)+

  annotate("text", x=12, y=2, label=nrow(DT_mean_difference[logFC>=1]), color="grey", fontface=2, size=4.5)+
  annotate("text", x=12, y=-2, label=(nrow(DT_mean_difference[logFC<=-1])+4), color="grey", fontface=2, size=4.5)+
  
  scale_x_continuous(breaks=seq(-5,15,1))+
  scale_y_continuous(breaks=seq(-20,10,2))+
  
  xlab("Average log-CPM")+
  ylab("Log2(fold change)")+
  
  annotate("text", x=11, y=8, label="UP-REGULATED", fontface=2, alpha=0.6, size=5)+
  annotate("text", x=11, y=-8, label="DOWN-REGULATED", fontface=2, alpha=0.6, size=5)+
  annotate("text", x=-5, y=10, label="A", fontface=2, size=7.5)+
  
  theme(axis.title = element_text(face="bold", size=22))

#Volcano plot
#1. Extracting log odds (i.e. -log10(p.value))
volcano_temp <- data.table(DT_read_count_filtered[,SYMBOL], DT_efit$lods[,1])
names(volcano_temp) <- c("ID","log.odds")
volcano_temp <- volcano_temp[!is.na(ID)]

#2. Merging log odds with logFc and adj.P.val data for plotting
DT_volcano <- merge(DT_mean_difference, volcano_temp, by="ID")

#3. Plotting function for volcano plot
volcano_plot <- ggplot(DT_volcano,aes(logFC,log.odds))+
  geom_jitter(DT_volcano[!(log.odds>1 & (logFC>=1 | logFC<=(-1)))], mapping=aes(logFC, log.odds), alpha=0.7, size=3)+
  geom_jitter(DT_volcano[log.odds>1 & (logFC>=1 | logFC<=(-1))], mapping=aes(logFC, log.odds), color="red", alpha=0.5, size=3)+
  geom_segment(aes(x=-1, xend=-1, y=-8,yend=8), size=1.5, color="dodgerblue2", linetype=2)+
  geom_segment(aes(x=1, xend=1, y=-8,yend=8), size=1.5, color="dodgerblue2", linetype=2)+
  geom_segment(aes(x=-7, xend=6, y=1, yend=1), size=0.5, color="dodgerblue2")+
  
  #geom_text_repel(DT_volcano[adj.P.Val<0.05 & (logFC<1 | logFC>1)][1:10], mapping=aes(label=ID), size = 6,  box.padding = unit(0.75, "lines"), point.padding = unit(0.1, "lines"), fontface=2, nudge_y = 1)+
  
  scale_y_continuous(breaks=seq(-10,50,5))+
  scale_x_continuous(breaks=seq(-7,6,1), limits=c(-7,6))+
  
  ylab("-log10(p.value)")+
  xlab("Log2(fold change)")+
  
  annotate("text", x=4, y=50, label="UP-REGULATION", fontface=2, alpha=0.6, size=4)+
  annotate("text", x=-4, y=50, label="DOWN-REGULATION", fontface=2, alpha=0.6, size=4)+
  annotate("text", x=-7, y=50, label="B", fontface=2, size=7.5)+
  
  theme(axis.title = element_text(face="bold", size=22))

####SECTION OUTPUT
plot_grid(mean_difference_plot, volcano_plot)

# ggsave("mean_difference_plot.jpg",mean_difference_plot, dpi=1000, height=7, width=14)
# ggsave("volcano_plot.jpg",volcano_plot, dpi=1000, height=7, width=14)

```

**Fig 12.** _Figure 11A reports a mean-difference plot which illustrates the number of over -and under expressed genes. Threshold is set at log2(fold change) +/-1 (blue lines). Blue dots represents genes above or below the log-fold change thresholds while red dots represent those genes which are above/below the thresholds and are significantly differentially expressed. Fig 11B is a volcano plot which reports the number of significantly over -and underexpressed genes (marked with red). Data in both plots is for the contrast "MSC[SCI] vs MSC[naive]"._

**Table 4. 10 most significantly up -and downregulated differentially expressed genes**

```{r echo=F, warning=F, message=F, error=F}
#Retrieving logFc and associated p-values for all genes
top_20_dge_retreiver <- function(dge.data, n, p.val.cutoff){
  top_20_dge_out <- data.table(toptable(dge.data, coef=1, number=Inf, genelist = DT_read_count_filtered[,ifelse(is.na(SYMBOL),ENSEMBL_ID, SYMBOL)]))
  top_20_dge_out <- top_20_dge_out[,.(ID, logFC=round(logFC,2), adj.P.Val=round(adj.P.Val, 4))]
  top_20_dge_out <- data.table(top_20_dge_out[logFC<-1 & adj.P.Val<p.val.cutoff][1:n], top_20_dge_out[logFC>1 & adj.P.Val<p.val.cutoff][1:n])
  return(top_20_dge_out)
}

###SECTION OUTPUT
kable(top_20_dge_retreiver(DT_efit,10,0.05), align="c", col.names = rep(c("Gene", "log2(fold change)","P-value (adjusted)"),2))
```

***

#Gene Ontology and KEGG Enrichment Analysis

**Gene Ontology (GO):** A major bioinformatics initiative which offers a computational representation of the biological function of genes at molecular, cellular and tissue level. This tool enables one to annotate genes with their function. 

**KEGG (Kyoto Encyclopedia of Genes and Genomes):** KEGG pathway are manually drawn pathway maps which represent the current knowledge within metabolism, cellular processes and many more.  

**Table 4. GO terms and KEGG pathways**

```{r echo=F, warning=F, message=F, error=F,fig.width=17, fig.height=7}
#1. Getting ENTREZ IDs for all genes in the filtered read count matrix 
entrez_ID <- data.table(select(Mus.musculus, keys=DT_read_count_filtered[,as.character(ENSEMBL_ID)], columns="ENTREZID", keytype = "ENSEMBL"))

#2. Removing duplicates
entrez_ID <- entrez_ID[!duplicated(ENSEMBL)]

#3. Gene ontology enrichment analysis
DT_GO <- goana(DT_efit, coef=1, geneid = entrez_ID[,as.character(ENTREZID)], FDR=0.05, species="Mm")
DT_GO_top <- data.table(topGO(DT_GO, sort="down", n=10))

#4. KEGG pathway enrichment analysis
DT_KEGG <- kegga(DT_efit, coef=1, geneid = entrez_ID[,as.character(ENTREZID)], FDR=0.05, species="Mm")
DT_KEGG_top <- data.table(topKEGG(DT_KEGG, sort="down", n=10))

###SECTION OUTPUT
kable(data.table(Type="GO", DT_GO_top), align=c("l", "l", rep("c", 6)))
kable(data.table(Type="KEGG", DT_KEGG_top), align=c("l", "l", rep("c", 6)))

```

***

# Unsupervised Clustering 2

##Agglomerative hierarchical clustering with heat map

**Background:** Purpose of hierarchical clustering in combination with heatmap is to find subset of genes which explain the difference between study groups.

**Hierarchical clustering:** An unsupervised statistical learning method which aims at clustering the data in a not pre-determined amount of clusters. In agglomerative hierarchical clustering the tree is built from the terminal nodes (leaves) towards the root. A dendrogram is utilized to displayed the clusterings. A heatmap is added to the hierarchical clustering to enable the identification of gene clusters which might explain the  hierarchical clustering. 

**Fig 13. Hierarchical clustering of samples together with heatmap of significantly differentially expressed genes **

```{r echo=F, warning=F, message=F, error=F, fig.width=30, fig.height=30}
#1. Subsetting data up to 100 most significant DE genes between allogenic and syngeneic (coef=4)
DT_logFC <- data.table(toptable(DT_efit, coef=1, number=Inf, genelist = DT_read_count_filtered[,ENSEMBL_ID]))
DT_logFC <- merge(DT_logFC, DT_read_count[,.(ENSEMBL_ID, SYMBOL)], by.x="ID", by.y="ENSEMBL_ID")
DT_logFC_significant <- DT_logFC[adj.P.Val<0.05]
setcolorder(DT_logFC_significant, c(1,7,2:6))
DT_logFC_significant[,"SYMBOL"] <- DT_logFC_significant[,.(ifelse(is.na(SYMBOL), ID, SYMBOL))]

#2. Retrieving the most significant genes from the log CPM matrix (i.e. heatmap is constructed using log CPm values)
DT_logFC_significant_lcpm <- DT_lcpm[DT_lcpm[,ENSEMBL_ID] %in% DT_logFC_significant[,ID]]

#3. Heatmap function
heatmap_plot_function <- function(heatmap.data, col.height, column.labels, dendrogram.setting, row.labels){
    heatmap.data <- data.matrix(heatmap.data)
    heatmap_plot_out <- heatmap.2(heatmap.data,
            scale="row",
            trace="none",
            density.info="none",
            dendrogram=dendrogram.setting,
            key=F,
            
            col=bluered(12),
            #labRow = row.labels,
            labRow = " ",
            labCol= column.labels,
            cexCol = 3,
            cexRow = 0.5,
            offsetRow = 0.1,
            offsetCol = 0.1,
            
            #margin=c(19,20),
            lhei=c(col.height,10),
            lwid=c(0.5,3))
  
    invisible(heatmap_plot_out)  
}

#4. Calculating p-value for hierarchical clustering
DT_hierarchical_clust <- data.matrix(DT_logFC_significant_lcpm[,3:length(DT_logFC_significant_lcpm)])
colnames(DT_hierarchical_clust) <- paste(DT_meta_data[,group]," ","(", DT_meta_data[,ID], ")", sep="")
DT_hierarchical_clust_boot <- pvclust(DT_hierarchical_clust, quiet=T)

###SECTION OUTPUT
heatmap_plot_function(DT_logFC_significant_lcpm[, 3:length(DT_logFC_significant_lcpm)], 2, DT_meta_data[,group], "both", DT_logFC_significant_lcpm[, as.character(ifelse(is.na(SYMBOL), ENSEMBL_ID, SYMBOL))])

# #Saving
# jpeg('heatmap.jpg',
#      width=2000,
#      height=2000,
#      quality=1000)
# heatmap_plot_function(DT_logFC_significant_lcpm[,c(3:14)],2,DT_meta_data[,sample],"both", DT_logFC_significant_lcpm[,as.character(ifelse(is.na(SYMBOL), ENSEMBL_ID, SYMBOL))])
# 
# dev.off()

```

**Fig 14.** _Figure reports a heat map with hierarchical clustering (indicated with dendrograms) using log-CPM values. Only significantly differentially expressed genes are included (and genes with NA symbols were removed)._ 

## Multiscale bootstrap resampling of agglomerative hierarchical clustering

**Fig 15. Multiscale bootstrap resampling of hierarchical clustering **

```{r echo=F, warning=F, message=F, error=F, fig.width=15, fig.height=7}
plot(DT_hierarchical_clust_boot, print.pv=T, float=-0.02, col.pv=c("darkred", "darkblue"), cex.pv=0.9, font.pv=2, print.num=F, main="", sub="", xlab="")
pvrect(DT_hierarchical_clust_boot)
```

**Fig 15.** _Figure reports hierarchical clustering using multiscale boostrap resampling with 1000 replicates. Numbers with red color are the approximately unbiased (AU) p-values while blue numbers represent bootstrap probability (BP). AU >95 and BP >70 are considered to be significant clusters. Red boxes indicate clusters with AU >95._

**Fig 16. Unsupervised clustering using the 1000 genes with the highest F value (between all contrasts)**

```{r echo=F, warning=F, message=F, error=F, fig.width=12, fig.height=5}
#1. Calculating F-statistica
DT_toptableF <- data.table(topTableF(DT_efit, number=Inf, genelist = DT_read_count_filtered[,SYMBOL]))

#2. Subsetting the 500 genes with the highest F-statistica
DT_toptableF <- DT_toptableF[!is.na(ProbeID)][1:1000, ProbeID]

#3. Retrieving log-CPM values for the genes
DT_toptableF <- DT_lcpm[DT_lcpm[,SYMBOL] %in% DT_toptableF]

#4. Creating a dissimilarity structure
DT_toptableF <- dist(t(DT_toptableF[,-(1:2)]))

#5. Hierarchical clustering  
DT_toptableF <- hclust(DT_toptableF)

#6. Drawing the dendrogram
myplclust(DT_toptableF, labels = paste(DT_meta_data[,group]," ","(", DT_meta_data[,ID], ")", sep=""), lab.col = brewer.pal(11,"RdBu")[c(1,2,10,11)][as.numeric(DT_meta_data[,group])], main=" ", ylab=" ", font=2, cex=1, hang=0.05)
```

**Fig 16.** _Figure reports a hierarchical clustering based on the 1000 genes with the highest F statistica (higher F statistica indicate a larger difference between contrasts)._

***

# Gene Set Testing

##Molecular Signatures Database

**Camera:** Performs a competitive gene set test which accounts for inter-gene correlations. Camera evaluates if a set of genes is highly ranked relative to other genes in terms of differential expression.  

**Barcode plot:** This function plots two sets of genes in a ranked list of statistics. Statistics are ranked left to right from smallest to largest. Shaded region in the middle of the plot represents the ranked statistics while the vertical bars reports the positions of the specified subsets. The enrichment worm (line) shows the relative enrichment of the vertical bars in each part of the plot.  

**Table 5. Significant and selected gene sets from MSigDB libraries** 

```{r echo=F, warning=F, message=F, error=F, fig.width=12, fig.height=6}
#1. Defining function which takes a specified index and runs the 'camera' function and returns a data_table
camera_function <- function(selected.index, type){
  data_out <- camera(DT_voom_raw, index=selected.index, design=DT_design, contrast = DT_contrast[,1], inter.gene.cor = 0.01)
  data_out <- data.table(GeneSet = rownames(data_out), Library=type, data_out)[,!"FDR"][,PValue:=format(PValue, digits=2, scientific=T)]
  setkey(data_out, GeneSet)  
  return(data_out)
}

# #2. Creating indices
# #C2
# load(url("http://bioinf.wehi.edu.au/software/MSigDB/mouse_c2_v5p1.rdata"))
# geneset_index_c2 <- ids2indices(Mm.c2,id=rownames(DT_read_count_filtered)) 
# #C5
# load(url("http://bioinf.wehi.edu.au/software/MSigDB/mouse_c5_v5p2.rdata"))
# geneset_index_c5 <- ids2indices(Mm.c5,id=rownames(DT_read_count_filtered)) 
# #C7
# load(url("http://bioinf.wehi.edu.au/software/MSigDB/mouse_c7_v5p2.rdata"))
# geneset_index_c7 <- ids2indices(Mm.c7,id=rownames(DT_read_count_filtered)) 
# #Hallmark
# load(url("http://bioinf.wehi.edu.au/software/MSigDB/mouse_H_v5p2.rdata"))
# geneset_index_hallmark <- ids2indices(Mm.H,id=rownames(DT_read_count_filtered)) 

#Selected and significant gene set from each 'library'
# c2_selected <- c()
# 
# c7_selected <- c()
# 
# hallmark_selected <- c()

####SECTION OUTPUT
# kable(rbind(camera_function(geneset_index_c2, "C2")[c2_selected], camera_function(geneset_index_c7, "C7")[c7_selected], camera_function(geneset_index_hallmark, "Hallmark")[hallmark_selected]), align = c("l", rep("c",4)), col.names = c("Gene set", "MSigDB","Genes (n)", "Direction", "P-value"))

```

**Fig 17. Barcode plot**

```{r echo=F, warning=F, message=F, error=F, fig.width=12, fig.height=6}
#1. Bar code plot for M1-M2 up and down (from C2)

# barcodeplot(DT_efit$t[,1], index = geneset_index_c2$COATES_MACROPHAGE_M1_VS_M2_UP, index2=geneset_index_c2$COATES_MACROPHAGE_M1_VS_M2_DN, main="M1/M2", cex.main=2)

# jpeg('barcode_m1_m2.jpg',
#      width=750,height=400, quality=1000)

```

```{r echo=F, warning=F, message=F, error=F}
#1. Select genes in clusters -> rank on logFC and p-value -> for sci/naive comparison. 


```



#Summary

**1. Annotation:** _Genes are annotated with gene name using their respective ENSEMBL ID._  
**2. Transformation:** _Read count matrix is transformed into log-CPM using original library sizes._  
**3. Filtering:** _Read count matrix is filtered using log-CPM values (>0 for at least 3 samples)._    
**4. Normalization:** _Effective library sizes are calculated using the library sizes for the filtered read count matrix and the trimmed mean of M values (TMM) approach._    
**5. Transformation:** _Filtered read count matrix is transformed into log-CPM matrix._    
**6. PCA:** _Conducted for the 500 genes with highest variance. Proportional variance explained, MDS and loading plots are created._    
**7. Design matrix:** _A dummy matrix which indicates which group each sample belongs._  
**8. Contrast matrix:** _Contrasts are the group comparisons of interest._    
**9. Voom transformation:** _Estimate precision weights for linear modelling to remove dependency between the variance and trhe mean._  
**10. Linear modelling:** _Linear modelling using precision weights followed by an empirical Bayes moderation._  
**11. Differentially expressed genes:** _Moderated t-statistics are used for determining significantly expressed genes for each contrast. Results are displayed with venn diagrams, mean-difference -and volcano plot and a summary table._  
**12. Analysis/interpretation:** _Using hierarchical clustering, heatmap, gene ontology and KEGG enrichment analysis and gene set analysis the difference between the study groups is sought for._   

# Bibliography

**[1]** _R Core Team (2016). R: A language and environment for statistical computing. R Foundation for Statistical Computing, Vienna, Austria. URL htts://www.R-project._

**[2]** _Ritchie, M.E., Phipson, B., Wu, D., Hu, Y., Law, C.W., Shi, W., and Smyth, G.K. (2015). limma powers differential expression analyses for RNA-sequencing and microarray studies. Nucleic Acids Research 43(7), e47._

**[3]** _Robinson MD, McCarthy DJ and Smyth GK (2010). edgeR: a Bioconductor package for differential expression analysis of digital gene expression data. Bioinformatics 26, 139-140_

**[4]** _Law CW, Alhamdoosh M, Su S et al. RNA-seq analysis is easy as 1-2-3 with limma, Glimma and edgeR [version 1; referees: 3 approved]. F1000Research 2016, 5:1408._

# Setup

This analysis was conducted on:

```{r echo=T, warning=F, message=F, error=F}
sessionInfo()
```
